# desingPattern

## sigleton pattern
 - 전역 변수를 사용하지 않고 객체를 하나만 생성 하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 패턴
 - 하나의 인스턴스만을 생성하는 책임이 있으며 getInstance 메서드를 통해 모든 클라이언트에게 동일한 인스턴스를 반환하는 작업을 수행한다

문제점
 - 경합 조건(Race Condition) 을 발생시키는 경우
    - 인스턴스가 아직 생성되지 않았을 때 스레드 1이 getInstance 메서드의 if문을 실행해 이미 인스턴스가 생성되었는지 확인한다. 현재 객체 변수는 null인 상태다.
만약 스레드 1이 생성자를 호출해 인스턴스를 만들기 전 스레드 2가 if문을 실행해 객체 변수가 null인지 확인한다. 현재 객체 변수는 null이므로 인스턴스를 생성하는 생성자를 호출하는 코드를 실행하게 된다.
스레드 1도 스레드 2와 마찬가지로 인스턴스를 생성하는 코드를 실행하게 되면 결과적으로 객체 클래스의 인스턴스가 2개 생성된다.
- 경합 조건이란?
    - 메모리와 같은 동일한 자원을 2개 이상의 스레드가 이용하려고 경합하는 현상

해결점
- 다중 스레드 애플리케이션이 아닌 경우에는 아무런 문제가 되지 않는다.

다중 스레드 애플리케이션에서 발생하는 문제를 해결하는 방법
1. 정적 변수에 인스턴스를 만들어 바로 초기화하는 방법 (Eager Initialization)
  - 객체가 생성되기 전 클래스가 메모리에 로딩될 때 만들어져 초기화가 한 번만 실행된다.
  - 프로그램 시작~종료까지 없어지지 않고 메모리에 계속 상주하며 클래스에서 생성된 모든 객체에서 참조할 수 있다.
2. 인스턴스를 만드는 메서드에 동기화(synchronized)하는 방법 (Thread-Safe Initialization)
  - 다중 스레드 환경에서 동시에 여러 스레드가 getInstance 메서드를 소유하는 객체에 접근하는 것을 방지한다.
  - 공유 변수(객체 property)에 접근하는 부분을 임계 구역으로 변경
    - 여러 개의 스레드가 하나뿐인 counter 변수 값에 동시에 접근해 갱신하는 것을 방지한다.
  - getInstance()에 Lock을 하는 방식이라 속도가 느리다.(비용이 비쌈. 병목현상이 일어남.)

예제 : 
## flyweight pattern

예제 : 


